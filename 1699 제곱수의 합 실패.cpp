#include <iostream>

using namespace std;

int main(void)
{
	// 제곱수의 합 최소 개수를 구하는 문제. 
	// 처음 생각:
	// 그냥 큰 수 순서대로 때려 넣으면 된다.
	// but, 그렇게 넣으면 안되는 경우가 무조건 있을 듯.
	// 예를 들면
	// 18같은 경우. 9 랑 9 넣으면 2개로 되는데 16넣으면 1 1넣어서 3개되야 됨.
	
	// 그리고 위와 같은 경우로 하면 경우의 수? 일단은 시간초과 가늠이 안됨.
	
	// dp 문제이기 때문에, 작은 문제가 큰 문제안에 세부적으로
	// 따라서 제곱수가 되는 수는 dp가 1이 될 것 
	 
	int n;
	cin >> n;
		
	int dp[100001] = { 0, };
	int i;
	
	// 100000이 마지막 수 그래서 320의 제곱이 100000범위 내 다 포함
	for(i = 1; i <= 320; ++i){
		int k = i * i;
		dp[k] = 1;
	}
	
	// 우선 2개로 표현 가능한 수부터 접근해보자.
	// 그렇게해서 많이 해봤자 100000개를 넣을건데 일단 작은 수부터.
	// 이런 식으로 할거면 100000 * 100000 이 필요해서 시간 초과임 2개부터.
	// 그러므로 다른 방법이 필요.
	
	// dp[i] = 1 인 인덱스부터 접근하면 어떨까?
	
	//그러면 dp[i] = 1이 되는 인덱스 바로 뒤의 수는 dp[i + 1] = 2가 될테고.
	// dp[i + 4] = 2, dp[i + 9] = 2 음. 근데 dp[i + 9] = 2부터 이상해지는게
	// dp[16]을 조사하면 1, 그리고 dp[i + 9]를 하면 dp[25] = 2로 만드는데
	// dp[25]는 1이기 때문.
	
	 
			 
	cout << dp[n] << endl; // 이 식이 답이 되도록 하는.
	
	return 0;
}


