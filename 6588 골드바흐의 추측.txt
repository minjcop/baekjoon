!에라스토테네스의 체
! cin을 사용할때는 ios_base::sync_with_stdio(false);와 cin.tie(NULL); 을,
! endl 을 사용할때는 개행문자를 대신 사용해주자.
!이과정에서 주의할점은.
1000000까지의 소수를 모두 조사해줘야지
500000까지만 조사해주면 n-i를 조사할때 문제가 생긴다. 또한, 
n/2까지 i를 조사할때는 i <= n/2를 해줘야 한다. i < n/2가 아니라.
i == j인 경우도 생각해줘야 한다.
!!

bool isPrime[1000001] = true; 로 설정해두고
for(int i = 2; i < 500000; ++i){
	if(isPrime[i]){
		for(int j = i*i; j <= 500000; j += i){
			isPrime[i] = false;
		}
	}
}


4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.
1000000이하의 모든 짝수에 대해서 이 추측을 검증하는 프로그램을 작성

Testcase 계속 주어짐(0이 나올때까지) T 개수는 100000이하.
6 <= n <= 1000000

n = a + b형태로 출력, n을 만들 수 있는 방법이 여러가지라면 b - a가 가장 큰것을 출력.

그러면. 일단 에라토스테네스의 체를 이용해서 
3부터 1000000까지의 수 중에서 2 ~ 1000 까지 비교해서
나누어 떨어지지 않는 소수인 것들을 전부 출력하고.
3부터 1000000까지의 수 중에서 2 ~ 1000 까지의 수로 나누어떨어지지 않으면 무조건 소수인가?
아닐수도있다.

3부터 1000000까지의 모든 소수를 찾는다. 그리고나서
a 와 b-a가 모두 소수인지를 찾으면 된다.

1) 숫자를 입력받은후 
a b-a // b는 n을 넣고 a는 3부터 증가시켜나가면서 검사한다. O(n/2) 홀수만 검사하면 되니까.
백만개를 십만번 테스트하니까
O(100000000000) 시간복잡도 천억 줄어도 500억
2)
500000까지의 모든 수를 소수인지체크하면 된다. 
체크한 후에 
소수들만 a에 집어넣어서 b도 소수인지를 검사하면 된다.


