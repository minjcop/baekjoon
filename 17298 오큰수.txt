!! 그 수 자체가 오큰수인 수
!! 배열 1000000 이상 사용 불가능.
!!  vector <int> v(n); //이렇게 n개의 벡터공간 할당 가능하다. 모두 0으로 초기화.


5 2 7
5의 오큰수가 7이라는 의미는 5와 7사이에 5보다 큰수가 없다는 뜻.
스택에 저장되면 내림차순으로 저장됨. 오름차순이 될 수 없는게, 오름차순이라면 이미 스택을 빠져 나갔어야 한다.
어떤 수의 오른쪽에 있으면서 가장 가까운 수(오큰수) 이후의 수는 오큰수가 될 수 없다.

n이 총 개수,
a[i]가 입력받은 수
구하지 못한 수의 인덱스는 스택에 넣고,
그 인덱스수의 오큰수를 구하면 오큰수를 기록한다
i가 구하지 못한 수(스택에 들어있는 수)의 인덱스라고 하면
a[i] < a[j] 인 수를 입력받으면
oh[i] = a[j] 가 된다는 말이다.

크기가 N인 수열 A = A1, A2, ... An이 있다.

수열의 각 원소 Ai에 대해서 오큰수를 구하려고 한다.
Ai의 오큰수는 Ai보다 오른쪽에 있으면서 큰 수중에서 가장 왼쪽에 있는 수.
그런 수가 없으면 -1.

수열의 크기 N ( 1 <= N <= 1000000)
둘째에 수열의 원소 A1 ~ An(1 <= Ai <= 1000000)이 주어진다.

매번 계산하려면 O(n^2)의 시간복잡도가 필요하다.
따라서. 다른 방법을 생각해야하는데.

큐를 사용하면 되지 않을까?

4
3 5 2 7을 입력한다고 하면
3을 입력하고
5 2 7 을 큐에 넣는다.
q1.top()을 이용해서 큐에 있는 수가 클때까지 비교하고,
이후q1.pop()을 하면
q2.push()
q1

큐 2개??

