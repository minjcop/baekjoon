!나머지 연산에서는 1을 빼고 계산하는 방식!!!외우자.

최고의 방법)
나머지가 나누는 수와 같은 경우를 제외해주고, 개수를 하나 더 추가하지 않기 위해서
나머지 -= 1을 해주고
나머지를 이용해서 구한다.
x -= 1;
for(int i = x; i <= M*N; i += M){
                if(i % N == y){
                    result = i+1;
                    break;
		}
}

ex) m = 10, n = 12라면
<1:1>	<1:11>
<2:2>	<2:12>
<3:3>	<3:1>
<4:4>
<5:5>
<6:6>
<7:7>
<8:8>
<9:9>
<10:10>					<10:12>(60번째)

M N x y가 주어질때 M N이 마지막해를 나타낸다고 하면 x:y는 몇번째 해를 나타내는지 구하는 프로그램을 작성하라
1600000000 (16억) 모든 경우를 다 고려한다면 시간초과가 발생할 것.
1 <= M, N <= 40000, 1 <= x <= M, 1 <= y <= N
<x:y>가 유효하지 않은 표현이면 -1를 출력한다.

하나하나 하면 안되기때문에 나머지를 사용해야 할 듯. 
주의) 나머지를 사용할때는 x,y가 1일때랑, 각각 M, N일때를 유의해야 한다.
N = 12
y = 9인 경우는 
8 21 33

풀이)
	// M = 10, N = 12일때 10*a + 3, 12*b + 9 // a는 임의의 수.
        // 거꾸로 하지 않고 그냥 생각해보면 1 ~ 16억까지의 수 i 중에서 
        // i % 10 == 3 && i % 12 == 9인 수를 구하면 된다.
        // 그렇다면 그냥 M과 N중에서 큰 수를 구해서. 그 값부터 조사하면 될듯.
        /*
        int result = -1;
        for(int i = 8; i <= 16억; i += 12){ // 8은 9-1. 이렇게 조사해야 나옴. 처음부터 1이므로. 그것을 고려해줘야 한다.
            if((i+1) % 10 == 3){ 
                result = i;
                break;
            }
        }
        cout << result;
        */

반례)

10 12 10 12
for(int i = 11; i <= 60; i += 12){
	if((i+1) % 10 == 10){
		result = i+1; //  i+1 = 12 24 36 48 60
	}
}

% 10 == 10이 나올 수가 없다.

그래서 x, y를 각각 M, N으로 나눈 나머지를 다시 저장해줄것이다.
그러면 10 % 10 = 0이 나오고 0 ~ 9의 숫자는 그대로 저장된다.

시간복잡도는 O(N) or O(M)

